import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


public class GF2 {

	public static void main(String[] args) {
		//Input Files
		String[] sa = inputFile("input.txt");
		
		//Parse input file into correct variables
		int mod = Integer.parseInt(sa[0]); //prime number p
		int mXDegree = Integer.parseInt(sa[1]); //degree of irreducible polynomial
		int[] mX = getPoly(mXDegree, sa[2]); //coefficients of m(x) from leading to constant
		int fXDegree = Integer.parseInt(sa[3]); //degree of f(x)
		int[] fX = getPoly(fXDegree, sa[4]); // coefficients of f(x),from leading coefficient to the constant
		int gXDegree = Integer.parseInt(sa[5]); //degree of g(x)
		int[] gX = getPoly(gXDegree, sa[6]); // coefficients of g(x),from leading coefficient to the constant
		
		//Get output
		String outputText = "Output Text: \n";
		outputText += toString(addMod(fX, gX, mod)) + "\n";		
		outputText += toString(subtractMod(fX, gX, mod)) + "\n";
		System.out.println(outputText);
	
	}
	public static String[] inputFile(String fileName){
		String[] sa = new String[7];
		String line = "";
		fileName = "/Users/zacharybensley/Documents/GitHub/SecurityInComputing/GF2/" + fileName;
        try (BufferedReader in = new BufferedReader(new FileReader(fileName))) {
            int i = 0;
            while((line = in.readLine()) != null){
            	System.out.println("Line: " + line);
                sa[i] = line;
                i++;
            }
        }
        catch (IOException e) {
            System.out.println("inputFile() ERROR");
        }
        finally {
            return sa;
        }
	}
	public static int[] getPoly(int degree, String unparsedPoly){
		//Create an array of size degree
		int[] poly = new int[degree + 1];
		
		String[] sa = unparsedPoly.split(" ");
		String stud = "";
		for(String s: sa){
			stud += s + " ";
		}
			System.out.println(stud);
		//Fill array from size to 0 with unparsedPoly
		for(int i = 0; i <= degree; i++){
			poly[i] = Integer.parseInt(sa[i]);
		}
		//return polyArray
		return poly;
	}
	public static int[] addMod(int[] x, int[] y, int mod){
		int i = 0;
		int j = 0;
		int[] outArray;
		//finds if x is larger than y
		if(x.length > y.length){
			outArray = new int[x.length];
			while(i < y.length - 1){
				outArray[i] = x[i++];
			}
			while(i < outArray.length){
				outArray[i] = x[i++] + y[j++];

			}
		}
		else if(y.length > x.length){
			outArray = new int[y.length];
			while(i < x.length - 1){
				outArray[i] = y[i++];
			}

			while(i < outArray.length){
				System.out.println("outArray.length: " + outArray.length);
				System.out.println("x.length: " + x.length);
				System.out.println("y.length: " + y.length);

				outArray[i] = x[j++] + y[i++];

			}		
		}
		else{
			outArray = new int[x.length];
			while(j < outArray.length){
				outArray[j] = x[j] + y[j];
				j++;
			}
		}

		makeModPositive(outArray, mod);
		outArray = removeLeadingZeros(outArray);
	
		return outArray;
	}
	public static int[] subtractMod(int[] x, int[] y, int mod){
		int i = 0;
		int j = 0;
		int[] outArray;
		//finds if x is larger than y
		if(x.length > y.length){
			outArray = new int[x.length];
			while(i < y.length - 1){
				outArray[i] = x[i++] - 0;
			}


			while(i < outArray.length){
				outArray[i] = x[i++] - y[j++];

			}
		}
		else if(y.length > x.length){
			outArray = new int[y.length];
			while(i < x.length - 1){
				outArray[i] = 0 - y[i++];
			}

			while(i < outArray.length){
				outArray[i] = x[j++] - y[i++];

			}		
		}
		else{
			outArray = new int[x.length];
			while(j < outArray.length){
				outArray[j] = x[j] - y[j++];
			}
		}
		
		makeModPositive(outArray, mod);
		outArray = removeLeadingZeros(outArray);
	
		return outArray;
	}
	/** 
	    * Algorithm EEA (Extended Euclidean algorithm)
	    * 
	    * @param a an (> 0) integer 
	    * @param b another (>= 0) integer 
	    * 
	    * @return int array (u,v) satisfying u*a + v*b = gcd(a,b)   
	    */
	    public static int[] EEA(int a, int b){        
	        if(b == 0){             
	            return new int[]{1,0};                        
	        }else{
	            int q = a/b; int r = a%b;
	            int[] R = EEA(b,r);
	            return new int[]{R[1], R[0]-q*R[1]};
	        }
	    }
		/** 
	    * Makes mod positive
	    * 
	    * @param a int[] The array to be made positive.
	    * @param mod The modulo value for the equation.
	 
	    */
	    public static void makeModPositive(int[] a, int mod){        
	    	for(int i = 0; i < a.length; i++){
	    		a[i] = a[i] % mod;
	    	}
	    	for(int j = 0; j < a.length; j++){
	    		if(a[j] < 0){
	    			a[j] = a[j] + mod;
	    		}
	    	}
	    }
	    
		/** 
	    * Remove leading zeroes
	    * 
	    * @param a an (> 0) integer  
	    */
	    public static int[] removeLeadingZeros(int[] a){ 
			int i = 0;
			boolean swap = false;
			while(i < a.length && a[i] == 0){
				swap = true;
				++i;
			}
			if(swap){
				int[] newA = new int[a.length - i];
				while(i < a.length){
					newA[i-1] = a[i]; 
					i++;
				}
				return newA;
			}
			return a;
	    }
	    public static String toString(int[] outArray){
	    	String s = "";
			for(int k = 0; k < outArray.length; k++){
				s += outArray[k] + " ";
			}
			return s;
	    }
}
